# 深度优先搜索(DFS)合并算法动画

## DFS算法概述

深度优先搜索(Depth-First Search, DFS)是一种用于遍历或搜索树或图的算法。在合并二叉树问题中，DFS按照前序遍历方式处理：先处理当前节点，然后递归处理左子树，最后递归处理右子树。

DFS算法的特点是"一路到底"——先沿着一条路径走到最深处，然后再回溯处理其他路径。这种方式非常适合使用递归实现。

## DFS合并二叉树的基本思路

1. 如果两棵树中有一棵为空，直接返回另一棵树
2. 如果两棵树都不为空，先合并当前节点（值相加）
3. 递归地合并左子树，并将结果作为新树的左子树
4. 递归地合并右子树，并将结果作为新树的右子树
5. 返回合并后的根节点

## 动画详细分镜

### 阶段1：初始化

**步骤1.1：展示问题**
- 视觉效果：
  - 左侧显示第一棵树(蓝色)
  - 右侧显示第二棵树(橙色)
  - 下方预留合并结果树的位置(灰色轮廓)
- 文本说明：
  - 标题："初始化：准备从两棵树的根节点开始合并"
  - 描述："我们将从两棵树的根节点开始合并。蓝色表示第一棵树，橙色表示第二棵树，绿色表示合并后的树。DFS会按照深度优先的顺序进行合并：先处理当前节点，然后处理左子树，最后处理右子树。"

**步骤1.2：标记根节点**
- 视觉效果：
  - 两棵树的根节点轻微放大(scale: 1.2)并添加轮廓高亮
- 文本说明：
  - 标题："标记根节点"
  - 描述："我们将从根节点开始进行DFS合并，首先关注两棵树的根节点，以它们为起点开始递归过程。"

### 阶段2：深度优先遍历与合并

**步骤2.1：合并根节点**
- 视觉效果：
  - 两个根节点高亮并放大(scale: 1.2)
  - 在合并树位置创建新的根节点(绿色)，初始透明度为0.7
  - 从两个根节点到新节点显示虚线连接
  - 新节点上显示值为两节点之和
- 文本说明：
  - 标题："合并根节点：值1 + 值2 = 合并值"
  - 描述："我们将两棵树根节点的值相加，形成新树的根节点。这是合并过程的第一步，也是递归的起点。当两个节点都不为空时，我们将值相加作为新节点的值。"

**步骤2.2：准备处理左子树**
- 视觉效果：
  - 根节点保持正常大小
  - 两棵树的左子节点轻微放大并高亮
  - 向左子树方向的边高亮
- 文本说明：
  - 标题："递归处理左子树"
  - 描述："现在我们向左移动，用相同的方法处理左子树。深度优先搜索(DFS)会先一直往左走到底，然后再回溯处理右边。"

**步骤2.3：递归合并左子节点**
- 视觉效果：
  - 两棵树的左子节点高亮并放大
  - 合并树中创建新的左子节点，连接到根节点
  - 显示左子节点的合并值
- 文本说明：
  - 标题："合并左子节点：值1 + 值2 = 合并值"
  - 描述："我们将两棵树左子节点的值相加，形成新树的左子节点。在DFS中，我们会一直沿着这条路径向下处理，直到遇到叶子节点或空节点。"

**步骤2.4：处理左子树的左子节点(空节点情况)**
- 视觉效果：
  - 如果某个树的节点为空，显示虚线框
  - 不为空的节点高亮
- 文本说明：
  - 标题："处理空节点情况"
  - 描述："当一侧树的节点为空时，我们直接使用另一侧树的节点。这是合并规则的第二条：如果只有一个节点存在，直接使用该节点。"

**步骤2.5：左子树处理完毕，回溯**
- 视觉效果：
  - 左子树的处理路径完整显示
  - 视觉上的"回溯"动画(箭头或轻微闪烁)
- 文本说明：
  - 标题："左子树处理完毕，回溯到上一层"
  - 描述："我们已经处理完左子树的所有节点(或遇到了空节点)，现在回溯到上一层，准备处理右子树。这是DFS算法的典型特征——深度遍历完成后回溯。"

**步骤2.6：递归处理右子树**
- 视觉效果：
  - 两棵树的右子节点高亮
  - 向右子树方向的边高亮
- 文本说明：
  - 标题："递归处理右子树"
  - 描述："左子树处理完毕，现在处理右子树。对于每个节点，我们都会先合并当前节点，然后先处理左子树，再处理右子树。"

**步骤2.7-2.10：类似于2.3-2.5，但处理右子树**
- 视觉效果和文本说明相似，但针对右子树

### 阶段3：递归深入

**步骤3.1-3.X：深入到更深层次**
- 视觉效果：
  - 动画依次处理树的更深层级
  - 每层都遵循同样的模式：处理当前节点，然后左子树，然后右子树
- 文本说明：
  - 为每个深度级别提供相应的说明，强调DFS一直向下直到叶子节点的特性

### 阶段4：特殊情况处理

**步骤4.1：处理两个空节点**
- 视觉效果：
  - 显示两个空节点位置(虚线框)
  - 简短的"X"动画表示返回null
- 文本说明：
  - 标题："遇到两个空节点，返回null"
  - 描述："当左右两边都没有节点时，表示这个位置没有节点，无需合并，直接返回空。这是合并规则的第三条：如果两个节点都不存在，结果为空。"

**步骤4.2：处理单一存在的节点**
- 视觉效果：
  - 高亮显示存在的节点
  - 另一侧显示空位置(虚线框)
  - 节点直接"移动"到结果树中相应位置
- 文本说明：
  - 标题："第一/二棵树节点为空，直接使用另一棵树的节点"
  - 描述："当一棵树的节点为空而另一棵不为空时，我们直接使用非空的节点。这种情况下，不需要值相加，直接复用已有节点。"

### 阶段5：完成合并

**步骤5.1：显示最终结果**
- 视觉效果：
  - 两棵原始树保持原位但降低透明度
  - 合并后的树完全显示，节点值清晰可见
  - 可能添加一个完成动画(如轻微放大再恢复)
- 文本说明：
  - 标题："合并完成！"
  - 描述："两棵二叉树合并完成！我们已经遍历了两棵树的所有节点，并按照规则将它们合并成了一棵新的二叉树。回顾一下合并规则：1) 如果两个节点都存在，值相加；2) 如果只有一个节点存在，直接使用该节点；3) 如果两个节点都不存在，结果为空。"

## DFS算法优劣分析

### 优势
1. **实现简单**：递归实现非常直观和简洁
2. **内存效率**：相比BFS，递归调用栈通常比显式队列使用更少的内存(对于平衡树)
3. **适合深层处理**：特别适合需要先处理深层节点的场景

### 局限性
1. **递归栈溢出风险**：对于非常深的树，可能导致栈溢出
2. **不保证最短路径**：如果用于搜索，不一定找到最短路径
3. **难以可视化完整过程**：由于其递归特性，对初学者可能较难理解整个过程

## 代码实现

```typescript
function mergeTrees(t1: TreeNode | null, t2: TreeNode | null): TreeNode | null {
  // 如果一个节点为空，返回另一个节点
  if (!t1) return t2;
  if (!t2) return t1;
  
  // 合并当前节点，值相加
  const merged = new TreeNode(t1.val + t2.val);
  
  // 递归合并左右子树
  merged.left = mergeTrees(t1.left, t2.left);
  merged.right = mergeTrees(t1.right, t2.right);
  
  return merged;
}
```

这段代码清晰展示了DFS合并二叉树的递归实现，对应我们的动画分镜中描述的各个步骤。 